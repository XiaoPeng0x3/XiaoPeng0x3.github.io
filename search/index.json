[{"content":"数据泛化 一些常见的统计方法 mean：均值，对于一组数据来说，计算其均值可以直接使用np.mean来进行计算，对于多维数据，numpy引入了轴axis的概念，其中，轴的起点从0开始一直到n，例如，在二维数据中，其中每一行代表一个样本，每一列代表一个特征(类似于csv文件)\n​\t长,宽,高\nx1\t1,2,3\nx2\t1,4,5\nx3\t1,6,7\n对于这样一组数据，用列表来表示就是\n1 2 3 4 data = [x1, x2, x3] data = [[1,2,3], [1,4,5], [1,6,7]] 其中，按照axis=0的方式来计算均值，这里计算的就是长、宽、高 每个特征的均长、均宽、均高，按照axis = 1来进行计算，也就是计算每一行的均值，也就是每一个样本的均值(看起来没有什么意义)\n1 2 mean1 = np.mean(data, axis=0) # 按照列进行计算 mean2 = np.mean(data, axis=1) # 按照行进行计算 下面所有的方法var(方差)，std(标准差)等均可以按照不同的轴进行计算\nvar:variance，方差，不在叙述计算公式，可以直接使用np.var()\nstd：Standard deviation,可以根据方差得到,可以直接使用`np.std()\nnp.round:保留小数操作，例如，要对data保留三位小数，可以表示为\n1 ans = np.round(data, 3) min-max均值规化 公式为\n$$ x\u0026rsquo; = \\frac{x-min}{max-min}$$\n对于一组数据data,可以这样计算\n1 2 3 4 5 def MinMax(data:np.ndarray) -\u0026gt; np.ndarray: data_max = np.max(data, axis=0) data_min = np.min(data, axis=0) ans = (data - data_min) / (data_max - data_min) return ans 标准化 标准化可以把各个特征标准化为标准差为1，均值为0的正态分布\n公式为\n$$ x = \\frac{x-\\mu}{\\sigma} $$\n其中， $\\mu$是均值，$\\sigma$是标准差\n1 2 3 4 5 def Standardization(data: np.ndarray) -\u0026gt; np.ndarray: data_mean = np.mean(data, axis=0) data_std = np.std(data, axis=0) ans = (data - data_mean) / data_std return ans 总结 是否必须使用标准化方法？\n算法需求： 某些算法（如距离-based的算法, K-means, K邻近）对特征尺度非常敏感，标准化几乎是必需的。 某些算法（如决策树、随机森林等）对特征尺度不敏感，标准化不是必需的。 数据特性： 如果特征的数值范围已经很接近，标准化的效果可能不明显。 如果特征的数值范围差异很大，标准化可以显著提升模型性能。 模型性能： 通过实验比较标准化前后的模型性能，可以决定是否需要标准化。 ","date":"2024-11-04T10:43:36+08:00","permalink":"https://XiaoPeng0x3.github.io/p/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E6%95%B0%E6%8D%AE%E6%B3%9B%E5%8C%96/","title":"深度学习基础系列：数据泛化"},{"content":"reshape reshape可以改变矩阵的维度，例如，有一个一维矩阵\n1 2 3 4 import numpy as np a = np.arange(20) # 转变为四行五列 ans = np.reshape(a, (4,5)) # 传入一个元组 转化前后数据量是一致的，20个元素不可以转换为3行4列\n","date":"2024-11-03T23:19:33+08:00","permalink":"https://XiaoPeng0x3.github.io/p/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%9F%A9%E9%98%B5%E5%8F%98%E5%9E%8B/","title":"深度学习基础系列：矩阵变型"},{"content":"矩阵的转置 矩阵的转置可以说是一个很常见的矩阵操作了，对于简单的矩阵(二维及以下)的矩阵来说，只需要调用numpy的T属性即可，例如\n1 2 3 4 5 6 7 import numpy as np a = [[1,2,3], [3,4,5], [5,6,7]] a_nparray = np.array(a) # 转换为ndarray a_T = a_nparray.T # 是一个属性 或者直接使用transpose\n1 2 3 4 5 6 import numpy as np a = [[1,2,3], [3,4,5], [5,6,7]] a_nparray = np.transpose(a) ","date":"2024-11-03T22:56:32+08:00","permalink":"https://XiaoPeng0x3.github.io/p/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%9F%A9%E9%98%B5%E8%BD%AC%E7%BD%AE/","title":"深度学习基础系列：矩阵转置"},{"content":"Softmax函数 softmax函数常用于多分类问题，我们希望模型的输出可以作为预测的概率，即输出值越大的那个参数在预测的时候很有可能就是正确答案。\n但是回想一下概率的计算公式(扔骰子)，对于总的概率空间样本来说，其概率的总和一定是1，而我们的预测输出基本上总和不可能是1，这里softmax函数的作用就是压缩这些输出值，从而使用概率的方式进行表示\nsoftmax函数长这样\n给定一个K维向量$ z=[z_1,z_2,\u0026hellip;,z_K]$，Softmax函数的定义为：\n这里，$\\mathbf{z}$ 是一个K维向量，$z_j$ 是向量中的第 $j$ 个元素，$ 1 \\leq j \\leq K$。\n$$ \\sigma(\\mathbf{z})j = \\frac{e^{z_j}}{\\sum{k=1}^{K} e^{z_k}} $$\n计算过程 对于给定的一个list输入，先计算得到softmax函数的分母值\n1 2 3 4 5 6 7 8 9 10 11 12 13 import math input = [1, 2, 3] # 分母是math.exp形式 ans = list() sumVal = 0.0 for val in scores: sumVal += math.exp(val) # 分母 for val in scores: ans.append(math.exp(val) / sumVal) print(ans) 我们也可以使用numpy进行计算\n1 2 3 4 5 6 7 8 import numpy as np def softmax(scores: list[float]) -\u0026gt; list[float]: temp = np.array(scores) # 转换为ndarray exp_temp = np.exp(temp) # 计算所有值的exp值 exp_sum = np.sum(exp_temp) # 和为分母 # 计算分子 exp_temp ans = np.round(exp_temp / exp_sum, 4) # 每个exp值除以分母，并保留4位小数 return ans numpy的方便之处在于不用编写循环和计算快！\n","date":"2024-11-02T10:46:57+08:00","permalink":"https://XiaoPeng0x3.github.io/p/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97softmax/","title":"深度学习基础系列：softmax"},{"content":"上次我们了解了怎么用Go语言来创建和连接一个socket，这里来看一看怎么封装用户行为以及怎么实现用户广播上线功能\nServer的封装 server 这是在上一节中提到的server结构\n1 2 3 4 type Server struct { Ip string Port int } 可以看到，我们只有两个简单的成员属性，为了实现用户上线后全部广播的操作，我们需要在server中记录下来每次连接到server的client，这里可以使用map来进行记录，同时，为了实现全局广播的效果，我们可以在server中使用一个chan来进行管理。\n为什么要实现server要实现一个chan通道呢，当有用户上线建立连接后，我们就可以把上线的这个消息发送给chan来进行管理，然后遍历map就可以实现广播的操作。\nserver的实现 需要在原来的基础上多增加一些属性\n1 2 3 4 5 6 7 8 9 10 type Server struct { Ip string Port int // 创建用户表 OnlineMap map[string]*User // 同步的锁 mapLock sync.RWMutex // 负责全局广播的chan Message chan string } 在创建好一个server后，与上一篇文章一样，使用协程去处理连接之后的状态\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 func (this *Server) Start() { // 创建好一个监听对象 // 这个函数会有两个返回值 // 一个是创建的 listen对象， 一个是是否创建成功 listener, err := net.Listen(\u0026#34;tcp\u0026#34;, fmt.Sprintf(\u0026#34;%s:%d\u0026#34;, this.Ip, this.Port)) // 创建失败的话， err就会有一个失败code // err != nil 就是说明创建失败 if err != nil { fmt.Println(\u0026#34;创建监听对象失败！, err\u0026#34;, err.Error()) return } // 启动之后记得关闭，避免浪费资源 defer listener.Close() // 然后就是使用accept方法 // 在一个循环里面不停的接受数据 // 监听 // 全局管道 go this.ListenMessage() for { // 这里的 meaage 是net.Coon类型 conn, err := listener.Accept() // 说明接收到了数据 if err != nil { fmt.Println(\u0026#34;监听失败！\u0026#34;) continue } // 打开一个协程去处理 go this.Handle(conn) // 下面的代码不会阻塞 } } 这里的Handle方法可以去处理连接请求，有哪些请求呢？\n当一个用户上线后，应该把这个用户添加到Online表中 广播这个用户上线的消息 看到这里，起始我们缺少封装的user类，我们可以再封装一个user类\nUser的封装 user类的实现 在user里面，基本的属性有Name, Address这些操作，为了更加方便User把消息转发给client(转发操作指的是conn.Write操作)，在消息接收的上我们可以初始化一个chan来进行连接转发\n1 2 3 4 5 6 type User struct { Name string Addr string C chan string conn net.Conn } C是为了接受来自server的消息，conn是为了把消息转发给client，那么在初始化的时候，就得去监听，看是否有消息写回来\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func NewUser(conn net.Conn) *User { userAddr := conn.RemoteAddr().String() // 可以得到客户端的地址 user := \u0026amp;User{ Name: userAddr, Addr: userAddr, C: make(chan string), conn: conn, } go user.ListenMessage() return user } // ListenMessage 监听User的chan func (this *User) ListenMessage() { for { mes := \u0026lt;-this.C this.conn.Write([]byte(mes + \u0026#34;\\n\u0026#34;)) } } 这样，在实现连接之后，我们就可以添加用户到在线表里面去\n1 2 3 4 5 6 7 8 9 10 11 12 func (this *Server) Handle(conn net.Conn) { // fmt.Println(\u0026#34;连接成功！\u0026#34;) // 执行到这里，说明已经有一个用户上线 newUser := NewUser(conn) this.mapLock.Lock() this.OnlineMap[newUser.Name] = newUser this.mapLock.Unlock() // 广播该用户已上线 this.Boardcast(newUser, \u0026#34;I am in!\u0026#34;) } user用户上线的广播 怎么实现Boardcast方法呢？可以直接利用server里面的chan来实现\n1 2 3 4 5 func (this *Server) Boardcast(u User, mes string) { // 把上线的消息发送给message chan sendMes := \u0026#34;[\u0026#34; + user.Name + user.Addr + mes + \u0026#34;]\u0026#34; this.Message \u0026lt;- sendMes // 发送给管道 } 在发送给管道后，server中的管道就就得到了数据，因此，就可以直接通过server中的chan进行消息的传输，遍历Onlinemap即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 func (this *Server) ShareMessage() { // 只要message有消息 // 那么就发送给在线的所有用户 for { mes := \u0026lt;-this.Message for _, user := range this.OnlineMap { this.mapLock.Lock() user.C \u0026lt;- mes this.mapLock.Unlock() } } } 最后在服务启动的时候去监听转发信息功能即可\n总结 整个流程看起来是这样的\n创建tcp套接字并开启连接 连接后会创建User对象 User对象会向Server的message发送信息 server的message接收到信息之后会遍历整个Online表，把User上线的消息发送给在Online表中的每一个User 其中，消息的转发依赖于conn.Write，User上线后把上线消息写入Serevr的chan，Server再把该User上线的消息通过Online表写入User的chan。\n","date":"2024-11-02T09:09:40+08:00","permalink":"https://XiaoPeng0x3.github.io/p/tcp%E8%81%8A%E5%A4%A9%E5%AE%A4%E4%BA%8C%E7%94%A8%E6%88%B7%E4%B8%8A%E7%BA%BF%E5%92%8C%E5%B9%BF%E6%92%AD/","title":"TCP聊天室(二)：用户上线和广播"},{"content":"前言 在学习完Go语言之后，总是感觉没有合适的上手项目进行练习，最近正好看到一个TCP网络聊天室的小项目，这个项目只使用基础的包而不使用任何框架，非常适合练手。\n需要的工具有\nGo开发环境 nc工具，方便模拟client进行测试 建立连接 在Go中，我们可以使用net包来进行基本的server的socket的创建，也就是net.Listen方法\n1 net.Listen() 下面是这个函数的原型\n1 2 3 4 5 // The network must be \u0026#34;tcp\u0026#34;, \u0026#34;tcp4\u0026#34;, \u0026#34;tcp6\u0026#34;, \u0026#34;unix\u0026#34; or \u0026#34;unixpacket\u0026#34;. func Listen(network, address string) (Listener, error) { var lc ListenConfig return lc.Listen(context.Background(), network, address) } 可以看到，函数的两个参数都是string类型的，第一个参数指定的是通信的网络(可以直接指定tcp), 第二个是server的地址。返回值就是监听对象和err\n例如，我们想要启动一个监听,就可以这样写\n1 2 3 4 listener, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:8080\u0026#34;) if err != nil { // To do } 就创建好了一个scoket\n在得到listener后，要开启接受功能，可以调用\n1 listener.Accept() 同样，这个函数有两个返回值，正常使用是这样的\n1 2 3 4 conn, err := listener.Accept() if err != nil { // To do } 其中，返回的是一个net.Conn类型的参数，可以通过conn在socket之间传递数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 type Conn interface { // Read reads data from the connection. // Read can be made to time out and return an error after a fixed // time limit; see SetDeadline and SetReadDeadline. Read(b []byte) (n int, err error) // Write writes data to the connection. // Write can be made to time out and return an error after a fixed // time limit; see SetDeadline and SetWriteDeadline. Write(b []byte) (n int, err error) // Close closes the connection. // Any blocked Read or Write operations will be unblocked and return errors. Close() error // LocalAddr returns the local network address, if known. LocalAddr() Addr // RemoteAddr returns the remote network address, if known. RemoteAddr() Addr // ........ // ........ } conn.Read可以从连接中读取数据(server可以read来自client的数据)， 同时conn.Write可以从连接中发送数据(server向client发送数据)\n这里就实现了通信的基石，即发送和接受数据，其整个过程就是\n创建socket：net.Listen,返回一个net.Listener对象 开始接收请求：listener.Accept,返回一个net.Conn对象 使用net.Conn实现接收数据和发送数据 simple demo 这里创建一个简单的demo程序，在server接收到来自client的数据后，把接受到的数据全部转换为大写后发送给client\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; ) func main() { ip := \u0026#34;127.0.0.1\u0026#34; port := 8080 //CreateServer(ip, port) listener, err := net.Listen(\u0026#34;tcp\u0026#34;, fmt.Sprintf(\u0026#34;%s:%d\u0026#34;, ip, port)) defer listener.Close() if err != nil { fmt.Println(\u0026#34;Eror!\u0026#34;, err) return } buf := make([]byte, 1024) conn, err := listener.Accept() defer conn.Close() for { if err != nil { fmt.Println(\u0026#34;connect fail\u0026#34;, err) return } // 读取数据 conn.Read(buf) // 写回数据 conn.Write(bytes.ToUpper(buf)) } } 然后使用nc工具\n1 nc 127.0.0.1 8080 当我们发送hello的时候，server正确的返回了HELLO\n思考：当有多个client的时候怎么办？\n协程处理 只有一个用户创建连接的时候可以正常返回，但此时有多个用户创建了连接请求，由于我们只accept了一次连接请求，所以当多个用户尝试连接的时候，第二个及之后的那些用户无法与服务器建立连接。\n解决办法\n每次在循环的过程中不断的进行监听，而不是只监听一次。 原始代码是\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // ..... conn, err := listener.Accept() // 把这里添加到循环中 defer conn.Close() for { if err != nil { fmt.Println(\u0026#34;connect fail\u0026#34;, err) return } // 读取数据 conn.Read(buf) // 写回数据 conn.Write(bytes.ToUpper(buf)) } } 添加到循环后就可以不断的建立连接\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // ...... for { conn, err := listener.Accept() if err != nil { fmt.Println(\u0026#34;connect fail\u0026#34;, err) return } // 读取数据 conn.Read(buf) // 写回数据 conn.Write(bytes.ToUpper(buf)) } } 然后再新建client的时候就可以处理多用户连接。\n这样写有什么问题？\n可以发现，当在一个client发送第二组数据后，server什么都没有返回，这是因为在循环执行到\n1 conn.Write(bytes.ToUpper(buf)) server一直在期待新的链接，而不是去处理之前的client的数据\n使用go协程\n在每次conn成功后，为了保持后续的链接，可以把后续的read和write封装为go协程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package main import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; ) func Handler(conn net.Conn) { defer conn.Close() buf := make([]byte, 1024) for { cnt, _ := conn.Read(buf) conn.Write(bytes.ToUpper(buf[:cnt])) } } func main() { ip := \u0026#34;127.0.0.1\u0026#34; port := 8080 //CreateServer(ip, port) listener, err := net.Listen(\u0026#34;tcp\u0026#34;, fmt.Sprintf(\u0026#34;%s:%d\u0026#34;, ip, port)) defer listener.Close() if err != nil { fmt.Println(\u0026#34;Eror!\u0026#34;, err) return } //defer conn.Close() for { conn, err := listener.Accept() if err != nil { fmt.Println(\u0026#34;connect fail\u0026#34;, err) return } go Handler(conn) } } 也就是说在主函数内，只负责去监听是否有用户链接，而链接后的读写就去创建一个新的协程，在这个协程内根据这个链接不断的去实现client-server之间的读写。\n总结 net.Listen：创建tcp socket, 返回listener对象 listener.Accept：监听客户端的连接, 返回net.Conn连接对象 net.Conn：实现read和write，读取和发送数据 go：开启一个协程 ","date":"2024-11-01T17:43:28+08:00","permalink":"https://XiaoPeng0x3.github.io/p/tcp%E8%81%8A%E5%A4%A9%E5%AE%A4%E4%B8%80tcp%E9%80%9A%E8%AE%AF/","title":"TCP聊天室(一)：tcp通讯"},{"content":"协方差矩阵 协方差(covariance)可以用来观测变量之间是否存在线性相关性。然而，协方差本身有一些局限性，因此在实际应用中，我们通常还会使用相关系数来进一步评估变量之间的相关性。\n协方差的局限性 尺度依赖性：\n协方差的值受变量尺度的影响。如果一个变量的值范围很大，而另一个变量的值范围很小，即使它们之间有很强的线性关系，协方差的绝对值也可能很大或很小，这使得直接比较不同变量之间的协方差变得困难。 单位依赖性：\n协方差的单位是两个变量单位的乘积。例如，如果一个变量的单位是米，另一个变量的单位是秒，那么协方差的单位将是米·秒。这使得协方差的解释更加复杂。 相关系数 为了克服协方差的这些局限性，我们通常使用 皮尔逊相关系数（Pearson correlation coefficient），它是一个标准化的协方差，范围在 -1 到 1 之间。\n皮尔逊相关系数的定义 皮尔逊相关系数 ( r ) 定义为： $$ r_{XY} = \\frac{\\text{Cov}(X, Y)}{\\sigma_X \\sigma_Y} $$\n其中：\n$\\sigma_X $ 是 X 的标准差。 $\\sigma_Y$ 是 Y 的标准差。 解释 ( r = 1 )：完全正相关，即两个变量完全同向变化。 ( r = -1 )：完全负相关，即两个变量完全反向变化。 ( r = 0 )：没有线性相关性。 ( |r| ) 接近 1：表示强相关性。 ( |r| ) 接近 0：表示弱相关性或没有相关性。 Python 示例 可以使用 numpy 或 pandas 库来计算皮尔逊相关系数。\n使用 numpy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import numpy as np # 示例数据 data = np.array([ [1, 4], # 观测值1 [2, 5], # 观测值2 [3, 6] # 观测值3 ]) # 计算协方差矩阵 cov_matrix = np.cov(data, rowvar=False) print(\u0026#34;协方差矩阵:\\n\u0026#34;, cov_matrix) # 计算相关系数矩阵 corr_matrix = np.corrcoef(data, rowvar=False) # correlation coefficient print(\u0026#34;相关系数矩阵:\\n\u0026#34;, corr_matrix) 这里的np.cov()和np.corrcoef()，如果不指定第二个参数，那么第二个参数默认rowvar = True，意思就是这组数据是按照横向放置的，意思就是每一行是一个属性\n而在有时候需要从文件里面读取一些属性，例如\n1 2 3 X\tY\tZ x1\ty1\tz1 x2\ty2\tz2 那么这个时候，就可以把默认值设置为False,代表每一列是一个属性\n使用 pandas 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import pandas as pd # 示例数据 data = pd.DataFrame({ \u0026#39;X\u0026#39;: [1, 2, 3], \u0026#39;Y\u0026#39;: [4, 5, 6] }) # 计算协方差矩阵 cov_matrix = data.cov() print(\u0026#34;协方差矩阵:\\n\u0026#34;, cov_matrix) # 计算相关系数矩阵 corr_matrix = data.corr() print(\u0026#34;相关系数矩阵:\\n\u0026#34;, corr_matrix) 结论 协方差提供关于变量之间线性关系的一些信息，但建议使用皮尔逊相关系数。\n相关系数不仅标准化了协方差，还提供了一个易于解释的度量，范围在 -1 到 1 之间。1代表存在正相关关系，-1代表负相关关系。\n","date":"2024-10-26T16:01:06+08:00","permalink":"https://XiaoPeng0x3.github.io/p/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5/","title":"深度学习基础系列：协方差矩阵"},{"content":"矩阵乘法 矩阵乘法是矩阵运算的基础，简单来说，对于两个A和B矩阵来说，只要A的列数等于B的行数，那么这两个矩阵就可以发生运算\n即A是一个m x n的矩阵， B是一个n x k的矩阵，那么运算后的结果就是m x k的矩阵\n首先把矩阵转换为np.array类型，然后判断它们的类型，查看是否可以相乘\n1 2 3 4 5 6 7 8 import numpy as np def matrix_dot_vector(a:list[list[int|float]],b:list[int|float])-\u0026gt; list[int|float]: a = np.array(a) b = np.array(b) if a.shape[1] != b.shape[0]: return -1 c = np.dot(a, b) return c np.dot()接受两个数组(矩阵)并返回它们的结果\n","date":"2024-10-25T23:41:00+08:00","permalink":"https://XiaoPeng0x3.github.io/p/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/","title":"深度学习基础系列：矩阵乘法"},{"content":"在上一篇中，我们学习了如何在server上创建一个TCP的套接字，这里来看一看对于服务端，server是怎么获取客户端的连接请求的。\n获取连接请求 在开启监听(listen)后，如果有客服端尝试连接服务器，那么内核将于客户端进行连接，因为请求连接可能会有多个，所以内核会维护一个队列来存放这些请求。当客户端连接到内核之后，那么内核可以使用accept函数来返回并接受来自这个连接。\n下面来用代码演示一下\n1 2 3 4 5 6 7 8 9 10 11 # 把上次的代码复制一下 from socket import * # 创建一个套接字 # 使用socket进行初始化 serverSocket = socket(AF_INET, SOCK_STREAM) # 使用IPV4地址簇，使用的是流式socket # 接下来开始进行绑定 serverSocket.bind((\u0026#34;127.0.0.1\u0026#34;, 8080)) # bind 需要的是一个tuple类型 # 绑定后可以开始listen, 即查看是否有客户端连接到服务器 serverSocket.listen(1) # 最多监听一个 在创建好server socket之后，我们就可以使用accept函数来进行连接。这里先不考虑TCP协议在连接时的一些细节\n1 2 3 4 5 6 \u0026#39;\u0026#39;\u0026#39; 返回值： connectionSocket 客户端连接套接字 addr 连接的客户端地址 \u0026#39;\u0026#39;\u0026#39; connectionSocket，addr = serverSocket.accept() 也就是说，这个操作会返回一个新的socket,不同的是，通过这个socket就可以实现server与client之间的通讯。\n可以接受或者发送数据，下面是一些API\n1 2 3 recv()/send() recvmsg()/sendmsg() recvfrom()/sendto() 需要注意的是，传递的这些字符全部都是流式数据，与原始字符串不同\n简单的demo 在这里，创建一个简单的小demo，我们可以创建一个简单的服务程序，这个server什么也不做，只是简单的把接受到的数据原封不动的发送给client\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from socket import * # 初始化好一个socket with socket(AF_INET, SOCK_STREAM) as serverScoket: # 绑定IP和port serverScoket.bind((\u0026#34;127.0.0.1\u0026#34;, 8080)) # 开启监听listen serverScoket.listen(1) # 这是一个监听队列，当处理多个请求的时候，会把未来得及处理的放入队列里面，其中的参数表示队列的大小 # 开启socket的accept,从而处理来自server的连接 connectionSocket, _ = serverScoket.accept() # 先忽略第二个返回值 print(\u0026#39;connect!\u0026#39;) with connectionSocket as c: while True: data = c.recv(1024) # 每次都尝试获得来自客户端的数据, 注意这是个字节流数据 if not data: break c.sendall(data) # 把接受到的数据返回 我们可以使用netcat这个工具来进行测试\n1 nc 1270.0.0.1 8080 可以看到，服务器端口已经连接上了\n1 connect! 通过这个有趣的连接，我们还可以使用eval函数来实现计算式求值\neval函数是危险的！这里只是做演示\neval() 可以执行任意的 Python 代码。如果传入的字符串包含恶意代码，这可能导致严重的安全漏洞。例如，攻击者可以通过构造恶意表达式来执行系统命令、访问敏感数据、修改文件等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from socket import * # 初始化好一个socket with socket(AF_INET, SOCK_STREAM) as serverScoket: # 绑定IP和port serverScoket.bind((\u0026#34;127.0.0.1\u0026#34;, 8080)) # 开启监听listen serverScoket.listen(1) # 这是一个监听队列，当处理多个请求的时候，会把未来得及处理的放入队列里面，其中的参数表示队列的大小 # 开启socket的accept,从而处理来自server的连接 connectionSocket, _ = serverScoket.accept() # 先忽略第二个返回值 print(\u0026#39;connect!\u0026#39;) with connectionSocket as c: while True: data = c.recv(1024) # 每次都尝试获得来自客户端的数据, 注意这是个字节流数据 if not data: break # 解码接收到的数据 expression = data.decode() # 计算表达式的结果 result = str(eval(expression))+\u0026#39;\\n\u0026#39; # 发送结果给客户端 c.sendall(result.encode()) 一些缺点 浪费性能 对于真实世界来说，这里的服务器实在是太弱了\n1 2 3 4 5 while True: data = c.recv(1024) if not data: break c.sendall(data) # 把接受到的数据返回 server每次只能处理一个请求，当client没有发送数据的时候，c.recv(1024)这行代码也就会永远阻塞在这里，很浪费性能。\n此时，很自然的想到以并发的方式去处理频繁的连接\n应对策略 多进程 可以使用fork来创建多个进程，其中，fork函数在子进程里面的返回值是0，所以，可以设想一下，当有服务来临时，父进程只去监听(accept)是否有连接，同时可以把读写操作放到子进程里面去运行，这样通过进程调度策略，就可以实现并发\n代码看起来是这样的：\n1 2 3 4 5 6 7 8 while (true) { pid_t pid; if ((pid = fork()) == 0) { // 子进程 // do read() or do write() } else { // accept } } 每当一个连接到来时，程序就会创建一个子进程来处理，可惜进程实在是不够“轻量”，而且进程调度器来进行调度的时候也需要有着内核态到用户态的转换、进程的变量读写保存，因此可以考虑使用多线程来进行尝试\n多线程 什么是线程？\nIn computer science, a thread of execution is the smallest sequence of programmed instructions that can be managed independently by a scheduler, which is typically a part of the operating system.[1] In many cases, a thread is a component of a process.\nThe multiple threads of a given process may be executed concurrently (via multithreading capabilities), sharing resources such as memory, while different processes do not share these resources. In particular, the threads of a process share its executable code and the values of its dynamically allocated variables and non-thread-local global variables at any given time.\nThe implementation of threads and processes differs between operating systems.\n线程是进程的一个子集(你可以这么认为)，一个进程里面会有多个线程，这些线程共享这个进程所有的资源(因为它们有着一样的页表)，所以在线程切换的时候，不需要有很大的开销，只需要维护每个线程内部不共享或者私有的数据即可。\n这样就可以使用多线程来处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import threading from socket import * # 把发送请求发送这里 def handle_client(c, addr): print(addr, \u0026#39;connect\u0026#39;) while True: data = c.recv(1024) if not data: break c.sendall(data) with socket(AF_INET, SOCK_STREAM) as serverSocket: serverSocket.bind((\u0026#34;127.0.0.1\u0026#34;, 8080)) serverSocket.listen() while True: connectionSocket, addr = serverSocket.accept() # 接受多个不同的请求 t = threading.Thread(target=handle_client, args=(connectionSocket, addr)) t.start() 多线程的方法可以使用线程池的方法去调度，不过线程也会占用系统的资源。\n结尾 之后记录一下select、poll、epoll这些方法\n","date":"2024-10-21T13:19:18+08:00","permalink":"https://XiaoPeng0x3.github.io/p/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%BA%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%8E%B7%E5%8F%96%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82/","title":"网络编程(二)：服务端获取连接请求"},{"content":"前言 这个系列会记录所有的学习计算机网络时的笔记。\n首先计算机网络很重要(Web开发)，网络在日常生活和学习中无处不在，但是你真的了解底层的那些细节吗？比如TCP/IP协议、UDP协议，在面试的时候可能会问到相关的细节。\n参考书籍 本次参考的书籍是：\n计算机网络：自顶向下\n在此基础上，可以选择一些视频资料进行辅助，推荐一门好评较高的课程：中科大——计算机网络，同时，如果觉得学了这些知识而缺少lab来动手的话，可以参考这门lab,如果觉得过于简单，也可以挑战一下CS144.\nSocket Socket的中文翻译是套接字，这个翻译很难理解，你可以把它认为是一个接口，插座之类的物品，或者认为它是一个介质。在日常生活中，很多都是Client-Server的模式，即客户端请求服务器上的一些资源，服务器在收到客户端的请求之后把数据发送到给客户端，这些数据就是通过套接字来实现的传输的。\n套接字（Socket）是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将 I/O 插入到网络中，并与网络中的其他应用程序进行通信。\n网络套接字是 IP 地址与端口 Port 的组合。\n为了满足不同的通信程序对通信质量和性能的要求，网络系统提供了三种不同类型的套接字，以供用户在设计网络应用程序时根据不同的要求来选择。分别是：\n流式套接字（SOCK-STREAM）。提供一种可靠的、面向连接的双向数据传输服务，**实现了数据无差错、无重复的发送。**流式套接字内设流量控制，被传输的数据看作是无记录边界的字节流。在 TCP/IP 协议簇中，使用 TCP 协议来实现字节流的传输，当用户想要发送大批量的数据或者对数据传输有较高的要求时，可以使用流式套接字。 数据报套接字（SOCK-DGRAM）。提供一种无连接、不可靠的双向数据传输服务。数据包以独立的形式被发送，并且保留了记录边界，不提供可靠性保证。数据在传输过程中可能会丢失或重复，并且不能保证在接收端按发送顺序接收数据。在 TCP/IP 协议簇中，使用 UDP 协议来实现数据报套接字。在出现差错的可能性较小或允许部分传输出错的应用场合，可以使用数据报套接字进行数据传输，这样通信的效率较高。 原始套接字（SOCK-RAW）。该套接字允许对较低层协议（如 IP 或 ICMP ）进行直接访问，常用于网络协议分析，检验新的网络协议实现，也可用于测试新配置或安装的网络设备。 这里需要记住两种协议：TCP和UDP，先不考虑它们底层是怎么实现的，TCP的特点就是可以保证在传送的过程中数据不丢失、不重复、不乱序，原原本本的把数据发送给接受者；而UDP协议考虑的很少，所以UDP协议可以用于传输速度快的场景。\n创建Socket 这里为了简单起见，使用Python来创建\n1 2 3 4 5 6 7 8 # 导入socket包 from socket import * # 创建一个TCP套接字 serverSocket = socket(AF_INET, SOCK_STREAM) # TCP是流式套接字 # 绑定Server的IP和Port serverSocket.bind((\u0026#34;127.0.0.1\u0026#34;, 8080)) # bind的参数是tuple类型，需要一个地址和端口 到这里，已经成功把serverSocket绑定到IP地址为127.0.0.1:8080的机器上了\n监听listen 在创建好serverSocket后，因为不知道什么时候server会收到连接请求，一个有效的方法是listen函数\n1 serverSocket.listen(1) 这里，函数的参数是监听队列的大小，当有多个连接请求时，这些请求会被放到监听队列里面。\n到目前为止，我们可以看一看serverSocket的一些信息\n1 print(ServerSocket) 下面是输出信息\n1 \u0026lt;socket.socket fd=340, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=(\u0026#39;127.0.0.1\u0026#39;, 8080)\u0026gt; 其中，第一个参数fd你可能不太了解，这个是一个文件描述符(file descriptor)，文件描述符是一个Obj的handle，或者你也可以理解为指向文件的指针，在Unix和类Unix系统中，所有的I/O都被抽象为文件描述符，包括网络套接字。\n流程 在创建一个socket时，可以遵循以下步骤\n根据协议初始化一个socket 给socket绑定IP 开启监听 关闭这个socket,防止内存泄漏 好，这就是创建socket的所有过程~~\n","date":"2024-10-20T17:31:13+08:00","permalink":"https://XiaoPeng0x3.github.io/p/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%80%E5%88%9D%E8%AF%86%E5%A5%97%E6%8E%A5%E5%AD%97/","title":"网络编程(一)：初识套接字"},{"content":"堆结构 许多应用程序都需要处理有序的元素，但是不一定要求它们全部有序，或是不一定要一次就将它们完全排好序。例如，你要实现一个进程调度算法，每一个进程都有一个优先级(当有电话到来时，你的游戏很可能会被打断)，所以电话程序的优先级会高于游戏程序的优先级。\n所以当前面临的挑战是：一个电脑上每个时刻都会有许多不同的进程，怎么按照优先级去调度它们呢？也就是说，在每次调度的时候，我们都希望花费很少的时间去找到最重要的进程(或者最不重要的进程)，堆结构就很好的解决这个问题。\n完全二叉树 二叉树是一种常见的结构，对于一个结点来说，它通常可以有两个子节点(left, right)，看起来是这样的：\n1 2 3 3 1 2 4 5 6 7 用代码来表示：\n1 2 3 4 5 type Tree struct { Val int // 值域 Left *Tree Right *Tree } 不过这里我们不会使用这种形式，可以使用数组来进行父子结点之间关系。\n完全二叉树是一个特殊的二叉树，下面是维基百科对完全二叉树的介绍\n在一颗二叉树中，若除最后一层外的其余层都是满的，并且最后一层要么是满的，要么在右边缺少连续若干节点，则此二叉树为完全二叉树（Complete Binary Tree）。具有n个节点的完全二叉树的深度。深度为k的完全二叉树，至少有个节点，至多有个节点。\n通俗点来说，完全二叉树就是满二叉树从后向前去除子节点后剩下的二叉树。简单来说，堆按照根节点与子节点的大小关系可以分为大根堆和小根堆。大根堆的根节点比所有的子节点大，小根堆的根节点比子节点都小。所以按照这种规则，大根堆的根节点一定是数组里面的最大值，小根堆的根节点一定是数组里面的最小值。\n堆的实现 首先，对于一个不是堆结构的数组来说，第一步要做的就是heapify堆化，堆化需要用到两个辅助函数，\n就是 sink和swim。\n从名字上来看，sink就是向下交换，swim就是向上交换，对于一个数组，我们可以从第一个非叶子结点开始堆化，对于这些非叶子结点，我们每次都进行堆化，这样初始化到数组的第一个元素的时候，整个数组就是堆结构了。\nsink方法 首先是找到这个数组的第一个非叶子结点，对于一个数组arr来说，我们假定它的长度是n，那么它的第一个非叶子结点就是(n-1) / 2，这里从大根堆开始建堆.\n首先，一个堆结构看起来可能是这样的：\n1 2 3 type MaxHeap struct { item []int } 它的sink方法是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func (this *MaxHeap) sink(k int) { n := len(this.item) // 孩子结点 for 2*k+1 \u0026lt; n { child := 2*k + 1 if child+1 \u0026lt; n \u0026amp;\u0026amp; this.item[child] \u0026lt; this.item[child+1] { child = child + 1 } // 没必要交换 if this.item[k] \u0026gt;= this.item[child] { break } // 交换两个元素 this.item[k], this.item[child] = this.item[child], this.item[k] k = child } } 上面这段代码的意思是，给定一个下标，让这个下标的元素向下交换，从而满足堆结构。然后就可以开始进行堆化的操作了\nheapify方法 1 2 3 4 5 6 7 func (this *MaxHeap) heapify() { // 从非叶子结点开始 n := len(this.item) for i := (n - 1) / 2; i \u0026gt;= 0; i-- { this.sink(i) } } 经过此次操作，我们就已经有了堆结构，item切片的第一个元素就是数组中的最大值。\nswim方法 但是，到目前为止，我们还没有让这个堆实现动态数据的添加和实现，当新增一个数据的时候，我们就把它添加到切片的结尾末尾，此时，这个新增的结点很可能会破坏掉原来的堆结构，这个时候，我们应该给新添加进来的元素找到合适的位置，swim方法就可以很好的实现。\n1 2 3 4 5 6 7 func (this *MaxHeap) swim(k int) { for k \u0026gt; 0 \u0026amp;\u0026amp; this.item[(k-1)/2] \u0026lt; this.item[k] { // 父节点比自己小 this.item[(k-1)/2], this.item[k] = this.item[k], this.item[(k-1)/2] k = (k - 1) / 2 // 注意这里啊 } } 添加与删除 添加一个元素时，需要动态的调整位置\n1 2 3 4 func (this *MaxHeap) insert(val int) { this.item = append(this.item, val) this.swim(len(this.item) - 1) } 删除一个元素的时候(一般是根节点)，这里有一个trick，根节点与最后一个结点进行交换，然后再把新的结点sink使得找到合适的位置，这样做是因为，数组不适合频繁的添加删除元素，这样做可以更加高效！\n1 2 3 4 5 6 7 8 9 10 func (this *MaxHeap) delMax() int { ans := this.item[0] this.item[0], this.item[len(this.item)-1] = this.item[len(this.item)-1], this.item[0] this.item = this.item[:len(this.item)-1] // 删除 this.sink(0) return ans } func (this *MaxHeap) getMax() int { return this.item[0] } 到此，我们就成功的实现了一个大顶堆，小顶堆的实现与之很相似，这里直接贴出代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 type MinHeap struct { item []int } func (this *MinHeap) heapify(nums []int) { this.item = nums n := len(this.item) for i := (n - 1) / 2; i \u0026gt;= 0; i-- { this.sink(i) } } func (this *MinHeap) sink(k int) { n := len(this.item) for 2*k+1 \u0026lt; n { child := 2*k + 1 if child+1 \u0026lt; n \u0026amp;\u0026amp; this.item[child+1] \u0026lt; this.item[child] { child = child + 1 } if this.item[k] \u0026lt;= this.item[child] { break } this.item[k], this.item[child] = this.item[child], this.item[k] k = child } } func (this *MinHeap) swim(k int) { for k \u0026gt; 0 \u0026amp;\u0026amp; this.item[(k-1)/2] \u0026gt; this.item[k] { this.item[k], this.item[(k-1)/2] = this.item[(k-1)/2], this.item[k] k = (k - 1) / 2 } } func (this *MinHeap) genLength() int { return len(this.item) } func (this *MinHeap) insert(val int) { this.item = append(this.item, val) this.swim(len(this.item) - 1) } 拓展：堆排序 在我们刚才构建大顶堆的时候，注意到每次都可以以 $O(logK)$的时间复杂度调整并获取最大值，所以，对于n组数来说，我们就可以以$O(nlogK)$的复杂度来进行排序，其中$K$是树的高度\n这里是完整代码，需要注意交换的范围每次都是在缩小的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package main import ( \u0026#34;fmt\u0026#34; ) // ConstructMaxHeap 将输入数组转换为最大堆。 func ConstructMaxHeap(nums []int) { n := len(nums) for i := n/2 - 1; i \u0026gt;= 0; i-- { sink(nums, i, n) } } // sink 是辅助函数，用于下沉元素以保持最大堆性质。 func sink(nums []int, k int, n int) { for 2*k+1 \u0026lt; n { child := 2*k + 1 if child+1 \u0026lt; n \u0026amp;\u0026amp; nums[child] \u0026lt; nums[child+1] { child = child + 1 } if nums[k] \u0026gt;= nums[child] { break } nums[k], nums[child] = nums[child], nums[k] k = child } } // heapSort 使用堆排序算法对输入的切片进行排序。 func heapSort(nums []int) { ConstructMaxHeap(nums) n := len(nums) for i := n - 1; i \u0026gt; 0; i-- { nums[i], nums[0] = nums[0], nums[i] // 交换最大元素到正确位置 sink(nums, 0, i) // 重新构建堆 } } func main() { nums := []int{3, 2, 1, 5, 6, 4} fmt.Println(\u0026#34;Original array:\u0026#34;, nums) heapSort(nums) fmt.Println(\u0026#34;Sorted array:\u0026#34;, nums) } ","date":"2024-10-19T19:47:58+08:00","permalink":"https://XiaoPeng0x3.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%A0%86/","title":"数据结构之堆"}]