[{"content":"前言 这个系列会记录所有的学习计算机网络时的笔记。\n首先计算机网络很重要(Web开发)，网络在日常生活和学习中无处不在，但是你真的了解底层的那些细节吗？比如TCP/IP协议、UDP协议，在面试的时候可能会问到相关的细节。\n参考书籍 本次参考的书籍是：\n计算机网络：自顶向下\n在此基础上，可以选择一些视频资料进行辅助，推荐一门好评较高的课程：中科大——计算机网络，同时，如果觉得学了这些知识而缺少lab来动手的话，可以参考这门lab,如果觉得过于简单，也可以挑战一下CS144.\nSocket Socket的中文翻译是套接字，这个翻译很难理解，你可以把它认为是一个接口，插座之类的物品，或者认为它是一个介质。在日常生活中，很多都是Client-Server的模式，即客户端请求服务器上的一些资源，服务器在收到客户端的请求之后把数据发送到给客户端，这些数据就是通过套接字来实现的传输的。\n套接字（Socket）是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将 I/O 插入到网络中，并与网络中的其他应用程序进行通信。\n网络套接字是 IP 地址与端口 Port 的组合。\n为了满足不同的通信程序对通信质量和性能的要求，网络系统提供了三种不同类型的套接字，以供用户在设计网络应用程序时根据不同的要求来选择。分别是：\n流式套接字（SOCK-STREAM）。提供一种可靠的、面向连接的双向数据传输服务，**实现了数据无差错、无重复的发送。**流式套接字内设流量控制，被传输的数据看作是无记录边界的字节流。在 TCP/IP 协议簇中，使用 TCP 协议来实现字节流的传输，当用户想要发送大批量的数据或者对数据传输有较高的要求时，可以使用流式套接字。 数据报套接字（SOCK-DGRAM）。提供一种无连接、不可靠的双向数据传输服务。数据包以独立的形式被发送，并且保留了记录边界，不提供可靠性保证。数据在传输过程中可能会丢失或重复，并且不能保证在接收端按发送顺序接收数据。在 TCP/IP 协议簇中，使用 UDP 协议来实现数据报套接字。在出现差错的可能性较小或允许部分传输出错的应用场合，可以使用数据报套接字进行数据传输，这样通信的效率较高。 原始套接字（SOCK-RAW）。该套接字允许对较低层协议（如 IP 或 ICMP ）进行直接访问，常用于网络协议分析，检验新的网络协议实现，也可用于测试新配置或安装的网络设备。 这里需要记住两种协议：TCP和UDP，先不考虑它们底层是怎么实现的，TCP的特点就是可以保证在传送的过程中数据不丢失、不重复、不乱序，原原本本的把数据发送给接受者；而UDP协议考虑的很少，所以UDP协议可以用于传输速度快的场景。\n创建Socket 这里为了简单起见，使用Python来创建\n1 2 3 4 5 6 7 8 # 导入socket包 from socket import * # 创建一个TCP套接字 serverSocket = socket(AF_INET, SOCK_STREAM) # TCP是流式套接字 # 绑定Server的IP和Port serverSocket.bind((\u0026#34;127.0.0.1\u0026#34;, 8080)) # bind的参数是tuple类型，需要一个地址和端口 到这里，已经成功把serverSocket绑定到IP地址为127.0.0.1:8080的机器上了\n监听listen 在创建好serverSocket后，因为不知道什么时候server会收到连接请求，一个有效的方法是listen函数\n1 serverSocket.listen(1) 这里，函数的参数是监听队列的大小，当有多个连接请求时，这些请求会被放到监听队列里面。\n到目前为止，我们可以看一看serverSocket的一些信息\n1 print(ServerSocket) 下面是输出信息\n1 \u0026lt;socket.socket fd=340, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=(\u0026#39;127.0.0.1\u0026#39;, 8080)\u0026gt; 其中，第一个参数fd你可能不太了解，这个是一个文件描述符(file descriptor)，文件描述符是一个Obj的handle，或者你也可以理解为指向文件的指针，在Unix和类Unix系统中，所有的I/O都被抽象为文件描述符，包括网络套接字。\n流程 在创建一个socket时，可以遵循以下步骤\n根据协议初始化一个socket 给socket绑定IP 开启监听 关闭这个socket,防止内存泄漏 好，这就是创建socket的所有过程~~\n","date":"2024-10-20T17:31:13+08:00","permalink":"https://XiaoPeng0x3.github.io/p/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%80%E5%88%9D%E8%AF%86%E5%A5%97%E6%8E%A5%E5%AD%97/","title":"网络编程(一)：初识套接字"},{"content":"堆结构 许多应用程序都需要处理有序的元素，但是不一定要求它们全部有序，或是不一定要一次就将它们完全排好序。例如，你要实现一个进程调度算法，每一个进程都有一个优先级(当有电话到来时，你的游戏很可能会被打断)，所以电话程序的优先级会高于游戏程序的优先级。\n所以当前面临的挑战是：一个电脑上每个时刻都会有许多不同的进程，怎么按照优先级去调度它们呢？也就是说，在每次调度的时候，我们都希望花费很少的时间去找到最重要的进程(或者最不重要的进程)，堆结构就很好的解决这个问题。\n完全二叉树 二叉树是一种常见的结构，对于一个结点来说，它通常可以有两个子节点(left, right)，看起来是这样的：\n1 2 3 3 1 2 4 5 6 7 用代码来表示：\n1 2 3 4 5 type Tree struct { Val int // 值域 Left *Tree Right *Tree } 不过这里我们不会使用这种形式，可以使用数组来进行父子结点之间关系。\n完全二叉树是一个特殊的二叉树，下面是维基百科对完全二叉树的介绍\n在一颗二叉树中，若除最后一层外的其余层都是满的，并且最后一层要么是满的，要么在右边缺少连续若干节点，则此二叉树为完全二叉树（Complete Binary Tree）。具有n个节点的完全二叉树的深度。深度为k的完全二叉树，至少有个节点，至多有个节点。\n通俗点来说，完全二叉树就是满二叉树从后向前去除子节点后剩下的二叉树。简单来说，堆按照根节点与子节点的大小关系可以分为大根堆和小根堆。大根堆的根节点比所有的子节点大，小根堆的根节点比子节点都小。所以按照这种规则，大根堆的根节点一定是数组里面的最大值，小根堆的根节点一定是数组里面的最小值。\n堆的实现 首先，对于一个不是堆结构的数组来说，第一步要做的就是heapify堆化，堆化需要用到两个辅助函数，\n就是 sink和swim。\n从名字上来看，sink就是向下交换，swim就是向上交换，对于一个数组，我们可以从第一个非叶子结点开始堆化，对于这些非叶子结点，我们每次都进行堆化，这样初始化到数组的第一个元素的时候，整个数组就是堆结构了。\nsink方法 首先是找到这个数组的第一个非叶子结点，对于一个数组arr来说，我们假定它的长度是n，那么它的第一个非叶子结点就是(n-1) / 2，这里从大根堆开始建堆.\n首先，一个堆结构看起来可能是这样的：\n1 2 3 type MaxHeap struct { item []int } 它的sink方法是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func (this *MaxHeap) sink(k int) { n := len(this.item) // 孩子结点 for 2*k+1 \u0026lt; n { child := 2*k + 1 if child+1 \u0026lt; n \u0026amp;\u0026amp; this.item[child] \u0026lt; this.item[child+1] { child = child + 1 } // 没必要交换 if this.item[k] \u0026gt;= this.item[child] { break } // 交换两个元素 this.item[k], this.item[child] = this.item[child], this.item[k] k = child } } 上面这段代码的意思是，给定一个下标，让这个下标的元素向下交换，从而满足堆结构。然后就可以开始进行堆化的操作了\nheapify方法 1 2 3 4 5 6 7 func (this *MaxHeap) heapify() { // 从非叶子结点开始 n := len(this.item) for i := (n - 1) / 2; i \u0026gt;= 0; i-- { this.sink(i) } } 经过此次操作，我们就已经有了堆结构，item切片的第一个元素就是数组中的最大值。\nswim方法 但是，到目前为止，我们还没有让这个堆实现动态数据的添加和实现，当新增一个数据的时候，我们就把它添加到切片的结尾末尾，此时，这个新增的结点很可能会破坏掉原来的堆结构，这个时候，我们应该给新添加进来的元素找到合适的位置，swim方法就可以很好的实现。\n1 2 3 4 5 6 7 func (this *MaxHeap) swim(k int) { for k \u0026gt; 0 \u0026amp;\u0026amp; this.item[(k-1)/2] \u0026lt; this.item[k] { // 父节点比自己小 this.item[(k-1)/2], this.item[k] = this.item[k], this.item[(k-1)/2] k = (k - 1) / 2 // 注意这里啊 } } 添加与删除 添加一个元素时，需要动态的调整位置\n1 2 3 4 func (this *MaxHeap) insert(val int) { this.item = append(this.item, val) this.swim(len(this.item) - 1) } 删除一个元素的时候(一般是根节点)，这里有一个trick，根节点与最后一个结点进行交换，然后再把新的结点sink使得找到合适的位置，这样做是因为，数组不适合频繁的添加删除元素，这样做可以更加高效！\n1 2 3 4 5 6 7 8 9 10 func (this *MaxHeap) delMax() int { ans := this.item[0] this.item[0], this.item[len(this.item)-1] = this.item[len(this.item)-1], this.item[0] this.item = this.item[:len(this.item)-1] // 删除 this.sink(0) return ans } func (this *MaxHeap) getMax() int { return this.item[0] } 到此，我们就成功的实现了一个大顶堆，小顶堆的实现与之很相似，这里直接贴出代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 type MinHeap struct { item []int } func (this *MinHeap) heapify(nums []int) { this.item = nums n := len(this.item) for i := (n - 1) / 2; i \u0026gt;= 0; i-- { this.sink(i) } } func (this *MinHeap) sink(k int) { n := len(this.item) for 2*k+1 \u0026lt; n { child := 2*k + 1 if child+1 \u0026lt; n \u0026amp;\u0026amp; this.item[child+1] \u0026lt; this.item[child] { child = child + 1 } if this.item[k] \u0026lt;= this.item[child] { break } this.item[k], this.item[child] = this.item[child], this.item[k] k = child } } func (this *MinHeap) swim(k int) { for k \u0026gt; 0 \u0026amp;\u0026amp; this.item[(k-1)/2] \u0026gt; this.item[k] { this.item[k], this.item[(k-1)/2] = this.item[(k-1)/2], this.item[k] k = (k - 1) / 2 } } func (this *MinHeap) genLength() int { return len(this.item) } func (this *MinHeap) insert(val int) { this.item = append(this.item, val) this.swim(len(this.item) - 1) } 拓展：堆排序 在我们刚才构建大顶堆的时候，注意到每次都可以以 $O(logK)$的时间复杂度调整并获取最大值，所以，对于n组数来说，我们就可以以$O(nlogK)$的复杂度来进行排序，其中$K$是树的高度\n这里是完整代码，需要注意交换的范围每次都是在缩小的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package main import ( \u0026#34;fmt\u0026#34; ) // ConstructMaxHeap 将输入数组转换为最大堆。 func ConstructMaxHeap(nums []int) { n := len(nums) for i := n/2 - 1; i \u0026gt;= 0; i-- { sink(nums, i, n) } } // sink 是辅助函数，用于下沉元素以保持最大堆性质。 func sink(nums []int, k int, n int) { for 2*k+1 \u0026lt; n { child := 2*k + 1 if child+1 \u0026lt; n \u0026amp;\u0026amp; nums[child] \u0026lt; nums[child+1] { child = child + 1 } if nums[k] \u0026gt;= nums[child] { break } nums[k], nums[child] = nums[child], nums[k] k = child } } // heapSort 使用堆排序算法对输入的切片进行排序。 func heapSort(nums []int) { ConstructMaxHeap(nums) n := len(nums) for i := n - 1; i \u0026gt; 0; i-- { nums[i], nums[0] = nums[0], nums[i] // 交换最大元素到正确位置 sink(nums, 0, i) // 重新构建堆 } } func main() { nums := []int{3, 2, 1, 5, 6, 4} fmt.Println(\u0026#34;Original array:\u0026#34;, nums) heapSort(nums) fmt.Println(\u0026#34;Sorted array:\u0026#34;, nums) } ","date":"2024-10-19T19:47:58+08:00","permalink":"https://XiaoPeng0x3.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%A0%86/","title":"数据结构之堆"}]